# 骨架屏显示逻辑修复说明

## 问题描述

之前的骨架屏实现存在一个问题：**骨架屏会在所有页面状态下显示**，包括：
- ✅ 初次加载时（预期行为）
- ❌ 点击刷新按钮时（不应该显示完整骨架屏）
- ❌ 数据加载过程中（不应该覆盖已有内容）

这导致用户每次点击刷新按钮，整个页面都会被骨架屏覆盖，用户体验不佳。

---

## 修复方案

### 核心思路
引入 **`initialLoading`** 标记来区分：
- **初次加载**：显示完整的骨架屏
- **后续刷新**：保留当前页面内容，仅在子区域显示局部加载状态

### 实现细节

#### 1. 新增状态变量
```javascript
const loading = ref(true)         // 页面加载状态
const initialLoading = ref(true)  // 初次加载标记（新增）
```

#### 2. 条件渲染逻辑

**完整骨架屏（仅初次加载）**
```vue
<!-- 只有初次加载且正在加载时才显示完整骨架屏 -->
<NodeManagerSkeleton v-if="loading && initialLoading" />
```

**主要内容区域**
```vue
<!-- 非初次加载或加载完成后显示实际内容 -->
<div v-else-if="!loading || !initialLoading" class="node-versions">
  <!-- 页面内容 -->
</div>
```

#### 3. 初次加载标记更新
```javascript
const refreshData = async () => {
  loading.value = true
  // ... 数据加载逻辑
  
  loading.value = false
  
  // 初次加载完成后，标记为非初次加载
  if (initialLoading.value) {
    initialLoading.value = false
  }
}
```

---

## 用户体验对比

### 修复前 ❌
1. 用户访问页面 → 看到骨架屏 ✅
2. 数据加载完成 → 显示内容 ✅
3. 用户点击刷新按钮 → **整个页面又被骨架屏覆盖** ❌
4. 用户操作其他功能时 → 可能再次看到骨架屏 ❌

**问题**：用户会感到困惑，为什么已经加载过的页面还要重新显示骨架屏？

### 修复后 ✅
1. 用户访问页面 → 看到骨架屏 ✅
2. 数据加载完成 → 显示内容 ✅
3. 用户点击刷新按钮 → **页面内容保持显示，只有子区域显示加载动画** ✅
4. 用户操作其他功能时 → 内容平滑更新 ✅

**优势**：用户体验更流畅，符合现代 Web 应用的交互习惯

---

## 局部加载状态

修复后，以下区域在数据加载时会显示**局部骨架屏**：

### 1. 推荐版本区域
```vue
<div v-if="loadingRecommended" class="skeleton-recommended-grid">
  <!-- 3个骨架卡片 -->
</div>
```

### 2. 可用版本表格区域
```vue
<div v-if="loadingAvailable" class="skeleton-table">
  <!-- 骨架表格：表头 + 5行数据 -->
</div>
```

这样既保证了加载反馈，又不会破坏整体页面的连续性。

---

## 页面状态流转图

```
初次访问页面
    ↓
loading=true, initialLoading=true
    ↓
显示完整骨架屏
    ↓
数据加载完成
    ↓
loading=false, initialLoading=false
    ↓
显示实际内容
    ↓
用户点击刷新
    ↓
loading=true, initialLoading=false
    ↓
保持内容显示 + 子区域显示局部骨架
    ↓
数据加载完成
    ↓
loading=false, initialLoading=false
    ↓
内容更新，无闪烁
```

---

## 技术要点

### 1. 条件渲染优先级
```vue
<!-- 顺序很重要 -->
v-if="loading && initialLoading"        <!-- 第一优先级 -->
v-else-if="!fnmStatus.installed"       <!-- 第二优先级 -->
v-else-if="!loading || !initialLoading" <!-- 第三优先级 -->
```

### 2. 状态更新时机
```javascript
// ⚠️ 必须在 finally 块中更新状态
finally {
  loading.value = false
  if (initialLoading.value) {
    initialLoading.value = false  // 只设置一次
  }
}
```

### 3. 避免状态冲突
- `loading` 控制当前是否正在加载
- `initialLoading` 只在第一次加载后设为 false，之后永不改变
- 两者结合使用，确保逻辑清晰

---

## 测试场景

### ✅ 场景1：初次访问
1. 打开 Node 管理页面
2. 应该看到完整骨架屏
3. 数据加载完成后，骨架屏消失，显示实际内容

### ✅ 场景2：点击刷新按钮
1. 在已加载的页面上点击"刷新"按钮
2. 页面内容应该保持显示
3. 推荐版本和可用版本区域显示局部骨架动画
4. 数据加载完成后，内容平滑更新

### ✅ 场景3：切换筛选条件
1. 切换"全部版本"和"仅 LTS"
2. 可用版本表格区域显示骨架表格
3. 其他内容保持不变
4. 新数据加载完成后，表格更新

### ✅ 场景4：搜索版本
1. 在搜索框输入关键词
2. 表格区域显示骨架动画
3. 搜索结果加载完成后显示
4. 页面其他部分不受影响

---

## 代码修改总结

### 修改文件
- `packages/cli/src/web/src/views/NodeManager.vue`

### 修改内容
1. **新增状态变量**: `initialLoading`
2. **修改条件渲染**: `v-if="loading && initialLoading"`
3. **修改内容区渲染**: `v-else-if="!loading || !initialLoading"`
4. **更新状态标记**: 在 `refreshData` 的 `finally` 块中设置

### 代码行数
- 新增: 3 行
- 修改: 4 行
- 总计: 7 行

---

## 最佳实践建议

### ✅ 推荐做法
1. **首屏加载**：使用完整骨架屏提升感知速度
2. **后续交互**：使用局部骨架屏保持内容连续性
3. **状态标记**：清晰区分初次加载和后续加载
4. **平滑过渡**：避免内容闪烁和跳动

### ❌ 避免做法
1. **过度使用骨架屏**：不要在每次数据更新时都显示完整骨架屏
2. **状态混乱**：不要用单一状态变量控制多个加载场景
3. **闪烁问题**：不要频繁切换显示/隐藏骨架屏
4. **无限骨架**：确保骨架屏有合理的超时处理

---

## 总结

本次修复解决了骨架屏过度显示的问题，通过引入 `initialLoading` 标记，精确控制骨架屏的显示时机：

- ✅ **初次加载**：完整骨架屏提升感知速度
- ✅ **后续刷新**：局部骨架屏保持内容连续性
- ✅ **用户体验**：流畅、自然、无闪烁

这种实现方式符合现代 Web 应用的最佳实践，为用户提供了更优质的交互体验。

---

**修复日期**: 2025-10-06  
**修复人员**: AI Assistant (claude 4.5 sonnet)  
**问题发现者**: 用户反馈
