# 项目打包版本管理功能使用指南

## 功能概述

在项目打包页面，系统会自动检测项目的 `package.json` 文件，并提供智能的版本管理功能。支持在打包前自动升级版本号，遵循语义化版本规范（SemVer）。

---

## 功能特性

### ✅ 自动版本检测
- 自动读取项目的当前版本号
- 识别项目类型（库项目/应用项目）
- 显示包名称和相关信息

### ✅ 灵活的版本升级策略
支持 4 种版本升级方式：

1. **不升级** - 保持当前版本不变
2. **Patch (x.x.+1)** - 修复 bug 或小改动
3. **Minor (x.+1.0)** - 新增功能但向后兼容
4. **Major (+1.0.0)** - 重大更新或不兼容改动

### ✅ 智能打包流程
- 选择版本升级策略后，打包前自动更新版本号
- 实时显示版本升级日志
- 版本升级失败自动取消打包

---

## 使用方法

### 1. 进入打包页面

在项目详情页面，点击 **"开始打包"** 按钮，进入打包页面。

### 2. 查看包信息

打包页面左侧会显示 **"包信息"** 卡片，包含：
- 包名称：`@ldesign/cache`
- 当前版本：`v1.0.0`
- 项目类型标识：**库项目** (如果是库)

### 3. 选择版本升级策略

在 **"版本升级策略"** 区域选择合适的升级方式：

#### 📦 不升级
```
适用场景：
- 调试构建
- 预览构建
- 不需要发布的构建
```

#### 🔧 Patch（补丁版本）
```
示例：1.2.3 → 1.2.4

适用场景：
- 修复 bug
- 文档更新
- 代码优化
- 依赖升级（无功能变化）
```

#### ✨ Minor（次要版本）
```
示例：1.2.3 → 1.3.0

适用场景：
- 新增功能
- API 扩展
- 向后兼容的改动
- 性能提升
```

#### 🚀 Major（主要版本）
```
示例：1.2.3 → 2.0.0

适用场景：
- 破坏性更新
- 重大架构调整
- 不兼容的 API 改动
- 完全重写
```

### 4. 开始打包

1. 选择好版本升级策略
2. 点击 **"开始打包"** 按钮
3. 系统会：
   - ① 先升级版本号（如果选择了升级）
   - ② 更新 `package.json` 文件
   - ③ 在日志中显示版本变化
   - ④ 开始执行打包操作

---

## 版本升级流程

### 流程图

```
选择版本策略 → 点击开始打包 → 自动升级版本 → 更新 package.json → 执行打包命令
```

### 日志示例

```log
[09:30:15] 正在升级版本号 (patch)...
[09:30:15] ✓ 版本已更新: 1.0.0 → 1.0.1
[09:30:15] 开始打包...
[09:30:15] 包名: @ldesign/cache
[09:30:15] 版本: 1.0.1
[09:30:15] 执行命令: pnpm run build
```

---

## 语义化版本规范 (SemVer)

版本号格式：`Major.Minor.Patch`

### 版本号含义

| 部分 | 说明 | 何时递增 |
|------|------|----------|
| **Major** | 主版本号 | 不兼容的 API 修改 |
| **Minor** | 次版本号 | 向下兼容的功能性新增 |
| **Patch** | 修订号 | 向下兼容的问题修正 |

### 版本示例

```
1.0.0  →  初始版本
1.0.1  →  修复 bug
1.1.0  →  新增功能
2.0.0  →  重大更新
```

---

## 最佳实践

### 📝 版本升级建议

#### 日常开发
- 修复 bug → 使用 **Patch**
- 新增功能 → 使用 **Minor**
- 测试构建 → 使用 **不升级**

#### 正式发布
- 向后兼容的新功能 → **Minor**
- 破坏性更新 → **Major**
- 紧急修复 → **Patch**

### 🔒 版本管理规范

1. **开发阶段**
   - 使用 `0.x.x` 版本号
   - 频繁使用 **Patch** 升级

2. **稳定阶段**
   - 从 `1.0.0` 开始
   - 谨慎使用 **Major** 升级
   - 详细记录 CHANGELOG

3. **维护阶段**
   - 主要使用 **Patch** 修复
   - 偶尔 **Minor** 新增功能
   - 避免 **Major** 变更

---

## API 接口

### 获取包信息
```
GET /api/projects/:id/package-info
```

**响应示例：**
```json
{
  "success": true,
  "data": {
    "name": "@ldesign/cache",
    "version": "1.0.0",
    "isLibrary": true,
    "projectType": "library",
    "description": "LDesign 缓存工具",
    "dependencies": { ... }
  }
}
```

### 更新版本号
```
POST /api/projects/:id/update-version
```

**请求参数：**
```json
{
  "bumpType": "patch" // none | patch | minor | major
}
```

**响应示例：**
```json
{
  "success": true,
  "data": {
    "oldVersion": "1.0.0",
    "newVersion": "1.0.1",
    "bumpType": "patch"
  },
  "message": "版本已更新: 1.0.0 -> 1.0.1"
}
```

### 预览版本升级
```
POST /api/projects/:id/preview-version
```

**请求参数：**
```json
{
  "bumpType": "minor"
}
```

**响应示例：**
```json
{
  "success": true,
  "data": {
    "currentVersion": "1.0.0",
    "newVersion": "1.1.0",
    "bumpType": "minor",
    "description": "新增功能但向后兼容（x.+1.0）"
  }
}
```

---

## 常见问题

### Q1: 版本升级失败怎么办？
**A**: 
1. 检查 `package.json` 文件是否存在
2. 确认文件权限是否正确
3. 查看日志中的错误信息
4. 手动修改版本号后重试

### Q2: 如何撤销版本升级？
**A**: 
- 版本号已写入 `package.json`，需要手动回退
- 建议使用版本控制系统（如 Git）进行回退
- 或手动编辑 `package.json` 恢复旧版本

### Q3: 打包时必须升级版本吗？
**A**: 
- 不是必须的，可以选择 **"不升级"** 选项
- 适用于测试构建、调试场景
- 正式发布建议升级版本

### Q4: 库项目和应用项目有什么区别？
**A**: 
- **库项目**：会发布到 npm，需要严格的版本管理
- **应用项目**：通常标记为 `private: true`，版本管理相对灵活
- 系统会自动识别并显示项目类型

### Q5: 版本号格式不正确怎么办？
**A**: 
- 确保版本号符合 SemVer 规范：`x.y.z`
- 每个部分必须是非负整数
- 不支持前缀（如 `v1.0.0`）
- 可以手动修改后重试

---

## 参考资料

- [语义化版本规范 (SemVer)](https://semver.org/lang/zh-CN/)
- [npm 版本管理最佳实践](https://docs.npmjs.com/about-semantic-versioning)
- [如何管理 npm 包版本](https://semver.npmjs.com/)

---

## 更新日志

### v1.0.0 (2025-01-30)
- ✨ 新增版本管理功能
- ✨ 支持 4 种版本升级策略
- ✨ 自动识别库项目
- ✨ 打包前自动升级版本
- ✨ 实时日志显示版本变化